In conclusion, this study addresses the design of an optimized parallel implementation of the Leiden algorithm \cite{com-traag19}, a high-quality community detection algorithm that improves upon the popular Louvain method \cite{com-blondel08}, in the shared memory setting. We extend optimizations for the Louvain algorithm \cite{sahu2023gvelouvain} to our implementation of the Leiden algorithm, and use a greedy refinement phase where vertices greedily optimize for delta-modularity within their community bounds, which we observe, offers both better performance and quality than a randomized approach.

On a system equipped with two 16-core Intel Xeon Gold 6226R processors, our implementation of the Leiden algorithm, referred to as GVE-Leiden, attains a processing rate of $352 M$ edges per second on a $3.8 B$ edge graph. It surpasses the original Leiden implementation, igraph Leiden, and NetworKit Leiden by factors of $373\times$, $86\times$, and $7.2\times$ respectively. GVE-Leiden identifies communities of equivalent quality to the first two implementations, and $26\%$ higher quality than NetworKit. Doubling the number of threads results in an average performance scaling of $1.6\times$ for GVE-Leiden. In comparison to GVE-Louvain \cite{sahu2023gvelouvain}, our parallel Louvain implementation, GVE-Leiden reduces internally-disconnected communities by a factor of $11$ with only a $36\%$ increase in runtime.

However, on average, communities identified by GVE-Leiden exhibit $88\times$, $145\times$, and $0.76\times$ more disconnected communities compared to the original Leiden, igraph Leiden, and NetworKit Leiden, respectively. This disparity is particularly noticeable on \textit{social networks}, \textit{road networks}, and \textit{protein k-mer graphs}. Despite this drawback, a potential solution is to address the issue by post-processing, where disconnected communities obtained from GVE-Leiden can be split. We acknowledge this concern, and plan to explore solutions in future work.
