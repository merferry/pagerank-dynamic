\subsection{Experimental Setup}
\label{sec:setup}

\subsubsection{System used}

We experiment on a system consisting of a $64$-core x86-based AMD EPYC-7742 processor running at $2.25$ GHz. Each core has an L1 cache of $4$ MB, an L2 cache of $32$ MB, and a shared L3 cache of $256$ MB. The server has $512$ GB DDR4 system memory, and runs on Ubuntu $20.04$.


\subsubsection{Configuration}

We use 32-bit integers for vertex ids and 64-bit floating point numbers for vertex ranks. To mark vertices as affected, we use an 8-bit integer vector. The rank computation uses OpenMP's \textit{dynamic schedule} with a chunk size of $2048$, which provides dynamic work-balancing among threads. We use a damping factor of $\alpha = 0.85$ \cite{rank-langville06}, an iteration tolerance of $\tau = 10^{-10}$ \cite{rank-dubey22} using $L\infty$-norm \cite{rank-plimpton11}, and limit the \texttt{MAX\_ITERATIONS} performed to $500$ \cite{nvgraph} for all experiments. We run all experiments with $64$ threads to match the number of cores available on the system (unless specified otherwise). For compilation, we use GCC $9.4$ and OpenMP $5.0$.


\subsubsection{Dataset}

We use four classes of graphs from the \textit{SuiteSparse Matrix Collection} \cite{suite19} in our experiments, shown in Table \ref{tab:dataset}. The number of vertices in these graphs varies from $3.07$ million to $214$ million, and the number of edges varies from $37.4$ million to $1.98$ billion. The presence of dead ends (vertices with no out-links) introduces a global teleport rank contribution that must be computed every iteration. We eliminate this overhead by adding self-loops to all the vertices in the graph (see also \cite{rank-andersen07, rank-langville06}).
%% We also use temporal graph for certain experiments, mention here?

\input{src/tab-dataset}


\subsubsection{Batch Generation}
\label{sec:batch-generation}

%% This needs to be updated
We take each base (static) graph from the dataset and generate a random batch update consisting of an equal mix of edge deletions and insertions. To prepare the set of edges deleted, we delete each existing edge with a uniform probability. We prepare the set of edges to insert by choosing pairs of vertices with equal probability. For the sake of simplicity, we ensure that no new vertices are added to or removed from the graph. We measure the batch size as a fraction of the total number of edges in the original graph and adjust it from $10^{-8}$ to $0.1$ (i.e., $10^{-8}|E|$ to $0.1|E|$), and generate multiple batches for each batch size (for averaging). Along with each batch update, we add self-loops to all vertices.


\subsubsection{Measurement}
\label{sec:measurement}

We measure the time taken by each approach on the updated graph entirely, including any preprocessing cost and the time taken to detect convergence, but exclude time taken for memory allocation and de-allocation. The average time taken by a given method at a given batch size is obtained by taking the geometric mean of time taken for the same batch size for each of the different input graphs. Accordingly, the average speedup is the ratio of these. Further, we measure the error/accuracy of a given approach by measuring the $L\infty$-norm of the ranks produced with respect to ranks obtained from a reference \textit{Static With-barrier} PageRank run on the updated graph with a very low tolerance of $\tau = 10^{-100}$ (limited to $500$ iterations).




\subsection{Comparing performance of DF-PageRank}

We first study the performance of \textit{Dynamic Frontier} PageRank on batch updates of size $10^{-7}|E|$ to $0.1|E|$ (in multiples of $10$), consisting purely of edge insertions, and compare it with \textit{Static}, \textit{Naive-dynamic}, and \textit{Dynamic Traversal} PageRank. As mentioned above, the edge insertions are generated uniformly at random. Figure \ref{fig:insertions-runtime} plots the runtime of \textit{Static}, \textit{Naive-dynamic}, \textit{Dynamic Traversal}, and \textit{Dynamic Frontier} PageRank; Figure \ref{fig:insertions-speedup} plots the speedup of \textit{Dynamic Frontier} PageRank with respect to \textit{Static}, \textit{Naive-dynamic}, and \textit{Dynamic Traversal} PageRank; and Figure \ref{fig:insertions-error} plots the error in ranks obtained with \textit{Static}, \textit{Naive-dynamic}, \textit{Dynamic Traversal}, and \textit{Dynamic Frontier} PageRank with respect to ranks obtained from a Reference Static PageRank (see Section \ref{sec:TODO} for details). \textit{Dynamic Frontier} PageRank is on average $8.3\times$, $2.7\times$, and $3.4\times$ faster than \textit{Static}, \textit{Naive-dynamic}, and \textit{Dynamic Traversal} PageRank on insertions-only batch updates of size $10^{-7}|E|$ to $10^{-3}|E|$, while obtaining ranks of better accuracy/error than \textit{Static} PageRank, and of similar accuracy/error as \textit{Naive-dynamic} and \textit{Dynamic Traversal} PageRank. On road networks, and protein k-mer graphs, \textit{Dynamic Frontier} PageRank is significantly faster than its competitors (\textit{Naive-dynamic} and \textit{Dynamic Traversal} PageRank).

We next study the performance of \textit{Dynamic Frontier} PageRank on batch updates of size $10^{-7}|E|$ to $0.1|E|$ (in multiples of $10$), consisting purely of edge deletions, and compare it with \textit{Static}, \textit{Naive-dynamic}, and \textit{Dynamic Traversal} PageRank. As above, the edge deletions are generated uniformly at random. Figure \ref{fig:deletions-runtime} plots the runtime of \textit{Static}, \textit{Naive-dynamic}, \textit{Dynamic Traversal}, and \textit{Dynamic Frontier} PageRank; Figure \ref{fig:deletions-speedup} plots the speedup of \textit{Dynamic Frontier} PageRank with respect to \textit{Static}, \textit{Naive-dynamic}, and \textit{Dynamic Traversal} PageRank; and Figure \ref{fig:deletions-error} plots the error in ranks obtained with \textit{Static}, \textit{Naive-dynamic}, \textit{Dynamic Traversal}, and \textit{Dynamic Frontier} PageRank with respect to ranks obtained from a Reference Static PageRank (see Section \ref{sec:TODO} for details). \textit{Dynamic Frontier} PageRank is on average $7.4\times$, $3.1\times$, and $4.1\times$ faster than \textit{Static}, \textit{Naive-dynamic}, and \textit{Dynamic Traversal} PageRank on deletions-only batch updates of size $10^{-7}|E|$ to $10^{-3}|E|$, while obtaining ranks of better accuracy/error than \textit{Static} PageRank (for batch sizes less than $0.1|E|$), and of similar accuracy/error as \textit{Naive-dynamic} and \textit{Dynamic Traversal} PageRank. On \textit{indochina-2004}, \textit{webbase-2001}, road networks, and protein k-mer graphs, \textit{Dynamic Frontier} PageRank is significantly faster than its competitors (\textit{Naive-dynamic} and \textit{Dynamic Traversal} PageRank).

Moving on, we study the performance of \textit{Dynamic Frontier} PageRank on batch updates of size $10^{-7}|E|$ to $0.1|E|$ (in multiples of $10$), consisting of $80\%$ edge insertions and $20\%$ edge deletions --- simulating realistic changes upon a dynamic graph, and compare it with \textit{Static}, \textit{Naive-dynamic}, and \textit{Dynamic Traversal} PageRank. As usual, the edge insertions and deletions are generated uniformly at random. Figure \ref{fig:deletions-runtime} plots the runtime of \textit{Static}, \textit{Naive-dynamic}, \textit{Dynamic Traversal}, and \textit{Dynamic Frontier} PageRank; Figure \ref{fig:deletions-speedup} plots the speedup of \textit{Dynamic Frontier} PageRank with respect to \textit{Static}, \textit{Naive-dynamic}, and \textit{Dynamic Traversal} PageRank; and Figure \ref{fig:deletions-error} plots the error in ranks obtained with \textit{Static}, \textit{Naive-dynamic}, \textit{Dynamic Traversal}, and \textit{Dynamic Frontier} PageRank with respect to ranks obtained from a Reference Static PageRank (see Section \ref{sec:TODO} for details). \textit{Dynamic Frontier} PageRank is on average $7.6\times$, $2.8\times$, and $4.1\times$ faster than \textit{Static}, \textit{Naive-dynamic}, and \textit{Dynamic Traversal} PageRank on $80\%$ insertions $20\%$ deletions batch updates of size $10^{-7}|E|$ to $10^{-3}|E|$, while obtaining ranks of better accuracy/error than \textit{Static} PageRank, and of similar accuracy/error as \textit{Naive-dynamic} and \textit{Dynamic Traversal} PageRank. On \textit{indochina-2004}, \textit{webbase-2001}, road networks, and protein k-mer graphs, \textit{Dynamic Frontier} PageRank is significantly faster than its competitors (\textit{Naive-dynamic} and \textit{Dynamic Traversal} PageRank).
% This seems to be associated to sparsity of the graphs as \textit{Dynamic Frontier} PageRank performing well on sparse graphs.

Figure \ref{fig:measure-affected} shows the total number of vertices marked as affected (average) by \textit{Dynamic Traversal} and \textit{Dynamic Frontier} PageRank on batch updates of size $10^{-7}|E|$ to $0.1|E|$. The Dynamic Frontier approach marks affected vertices incrementally --- thus, the final percentage (at the end of all iterations) is depicted in the figure. It is clear from the figure that \textit{Dynamic Traversal} PageRank marks a significantly higher percentage of vertices as affected, even for small batch updates. This is likely due the randomly generated edges in the batch update being part of large Strongly Connected Components (SCCs), or due to a large number of such SCCs being reachable from the vertices that are part of the batch update. In contrast, \textit{Dynamic Frontier} PageRank marks far fewer vertices as affected, as it incrementally expands the affected region of the graph only after the rank of an affected vertex changes by a substantial amount, i.e., by Frontier tolerance $\tau_f = \tau / 10^5$, where $\tau$ is the iteration/convergence tolerance (using $L\infty$-norm). In addition, as \textit{Dynamic Frontier} PageRank incrementally marks vertices as affected, the actual work performed by the algorithm is lower than that indicated by the percentage of affected vertices in Figure \ref{fig:measure-affected}.

% However, our experiments show that the \textit{Dynamic Traversal} approach does not perform better than the \textit{Naive-dynamic} approach for any batch size. The overhead of this approach, due to several traversals required to identify the affected vertices, limits the performance of this approach.

\input{src/fig-insertions-runtime}
\input{src/fig-insertions-speedup}
\input{src/fig-insertions-error}
\input{src/fig-deletions-runtime}
\input{src/fig-deletions-speedup}
\input{src/fig-deletions-error}
\input{src/fig-8020-runtime}
\input{src/fig-8020-speedup}
\input{src/fig-8020-error}
\input{src/fig-measure-affected}




\subsection{Strong Scaling of DF-PageRank}

We next study the strong-scaling behavior of \FroWbar{} and \FroBarf{} on batch updates of a fixed size of $10^{-4} |E|$ in the absence of faults. Here, we measure the speedup of each algorithm with an increasing number of threads from $1$ to $64$ in multiples of $2$ with respect to a single-threaded execution of the algorithm. We additionally compare \StaWbar{}, \StaBarf{}, \NaiWbar{}, and \NaiBarf{}.

We observe from Figure \ref{fig:strong-scaling} that all algorithms exhibit a good decrease in their run time over increasing number of threads. With $64$ threads, \StaBarf{}, \NaiBarf{}, and \FroBarf{} offers an average speedup of $21\times$, while \StaWbar{}, \NaiWbar{}, and \FroWbar{} offer an average speedup of $15\times$ over a single thread.
% Thus, \FroBarf{} offers good scaling performance.


\subsection{Weak Scaling of DF-PageRank}

\subsection{Behavior of DF-PageRank on Temporal Graphs}
